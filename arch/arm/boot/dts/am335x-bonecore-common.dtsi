#include <dt-bindings/board/am335x-bbw-bbb-base.h>

&am33xx_pinmux {
  bonecore_pins: pinmux_bonecore_pins {
    pinctrl-single,pins = <
      /* AM33XX_IOPAD(0x9b0, PIN_OUTPUT_PULLDOWN | MUX_MODE3) */  /* Example */

      BONE_P8_26 (PIN_INPUT_PULLUP | MUX_MODE7)  /* network reset */ 
      BONE_P8_31 (PIN_OUTPUT_PULLUP | MUX_MODE7)	 /* nEXT Power Enable GPIO */ 
      BONE_P8_32 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)  /* core_capprechargeA */ 

      BONE_P9_12 (PIN_OUTPUT_PULLUP | MUX_MODE7)  /* core_phyresetcmd */
      BONE_P9_15 (PIN_OUTPUT_PULLUP | MUX_MODE7)  /* i2c2_en */ 
    >;
  };
};

&capeuniversal {
  P8_26 {
    gpio-name = "nnetreset";
    gpio = <&gpio1 29 0>;
    input; dir-changeable;
  };
  P8_31 {
    gpio-name = "nextpwren";
    gpio = <&gpio0 10 0>;
    output; init-high; dir-changeable;
  };
  P8_32 {
    gpio-name = "capprechargea";
    gpio = <&gpio0 11 0>;
    output; init-low; dir-changeable;
  };
  P9_12 {
    gpio-name = "nphyresetcmd";
    gpio = <&gpio1 28 0>;
    output; init-high; dir-changeable;
  };
  P9_15 {
    gpio-name = "nsys5voutilimit";
    gpio = <&gpio1 16 0>;
    output; init-low; dir-changeable;
  };
};

&i2c2 {
  rtc1: rtc1@68 {
    compatible = "dallas,ds1307";
    reg = <0x68>;
  };
};

&tscadc {
  status = "okay";

  adc {
    ti,adc-channels = <0 1 2 3 4 5 6 7>;
    // BeagleBone Black (and most other variants):
		//	ch 0	P9.39
		//	ch 1	P9.40
		//	ch 2	P9.37
		//	ch 3	P9.38
		//	ch 4	P9.33
		//	ch 5	P9.36
		//	ch 6	P9.35
		//	ch 7	measures 0.5 * VDD_3V3B with 2.4 k立 source impedance

    // For each step, number of adc clock cycles to wait between setting up muxes and sampling.
		//	range: 0 .. 262143
		//	optional, default is 152 (XXX but why?!)
		ti,chan-step-opendelay = <152 152 152 152 152 152 152 152>;

    // For each step, how many times it should sample to average.
		//	range: 1 .. 16, must be power of two (i.e. 1, 2, 4, 8, or 16)
		//	optional, default is 16
		ti,chan-step-avg = <16 16 16 16 16 16 16 16>;

    // For each step, number of adc clock cycles to sample minus two.
		//	range: 0 .. 255   (resulting in sampling time of 2 .. 257 cycles)
		//	optional, default is 0
		ti,chan-step-sampledelay = <0 0 0 0 0 0 0 0>;
    // If this is set too low, accuracy will deteriorate when the thing you're measuring has a
		// high source impedance.  The maximum source impedance recommended (by erratum 1.0.32) is:
		//	(2 + sampledelay) * 2.873 k立 - 0.2 k立
		// which means that the default should be fine for source impedance up to 5.5 k立.
    		//
		// (This seems to ensure the sampling time is at least 21 times the RC constant, based on
		// the 5.5 pF nominal capacitance specified in the datasheet.)


		// After sampling, conversion time is 13 adc clock cycles.
		//
		// The adc clock frequency is 3 MHz, therefore the total time per step in microseconds is:
		//	( opendelay + avg * ( 2 + sampledelay + 13 ) ) / 3
		//
		// If all steps use the same timings then the sample rate will be:
		//	3 MHz / ( opendelay + avg * ( 2 + sampledelay + 13 ) ) / number_of_steps
		//
		// The highest samplerate obtainable (avg=1, opendelay=0, sampledelay=0) is therefore:
		//	200 kHz / number_of_steps
		//	= 25 kHz    when using all 8 steps.
		//
		// Using avg=16 reduces that to:
		//	12.5 kHz / number_of_steps
		//	= 1.5625 kHz    when using all 8 steps.
		//
		// Using the default values (avg=16, opendelay=152, sampledelay=0) reduces that to:
		//	7.653 kHz / number_of_steps
		//	= 0.9566 kHz    when using all 8 steps.
  };
};

&pruss {
  status = "okay";
};

&cape_eeprom0 { status = "disabled"; };
&cape_eeprom1 { status = "disabled"; };
&cape_eeprom2 { status = "disabled"; };
&cape_eeprom3 { status = "disabled"; };

&rtc { status = "disabled"; };
